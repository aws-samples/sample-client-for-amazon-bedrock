import { Serializable } from "../load/serializable.js";
import type { StringWithAutocomplete } from "../utils/types.js";
export interface StoredMessageData {
    content: string;
    role: string | undefined;
    name: string | undefined;
    tool_call_id: string | undefined;
    additional_kwargs?: Record<string, any>;
}
export interface StoredMessage {
    type: string;
    data: StoredMessageData;
}
export interface StoredGeneration {
    text: string;
    message?: StoredMessage;
}
export type MessageType = "human" | "ai" | "generic" | "system" | "function" | "tool";
type ImageDetail = "auto" | "low" | "high";
export type MessageContentText = {
    type: "text";
    text: string;
};
export type MessageContentImageUrl = {
    type: "image_url";
    image_url: string | {
        url: string;
        detail?: ImageDetail;
    };
};
export type MessageContentComplex = MessageContentText | MessageContentImageUrl;
export type MessageContent = string | MessageContentComplex[];
export interface FunctionCall {
    /**
     * The arguments to call the function with, as generated by the model in JSON
     * format. Note that the model does not always generate valid JSON, and may
     * hallucinate parameters not defined by your function schema. Validate the
     * arguments in your code before calling your function.
     */
    arguments: string;
    /**
     * The name of the function to call.
     */
    name: string;
}
export interface ToolCall {
    /**
     * The ID of the tool call.
     */
    id: string;
    /**
     * The function that the model called.
     */
    function: FunctionCall;
    /**
     * The type of the tool. Currently, only `function` is supported.
     */
    type: "function";
}
export interface BaseMessageFields {
    content: MessageContent;
    name?: string;
    additional_kwargs?: {
        function_call?: FunctionCall;
        tool_calls?: ToolCall[];
        [key: string]: unknown;
    };
}
export interface ChatMessageFieldsWithRole extends BaseMessageFields {
    role: string;
}
export interface FunctionMessageFieldsWithName extends BaseMessageFields {
    name: string;
}
export interface ToolMessageFieldsWithToolCallId extends BaseMessageFields {
    tool_call_id: string;
}
/**
 * Base class for all types of messages in a conversation. It includes
 * properties like `content`, `name`, and `additional_kwargs`. It also
 * includes methods like `toDict()` and `_getType()`.
 */
export declare abstract class BaseMessage extends Serializable implements BaseMessageFields {
    lc_namespace: string[];
    lc_serializable: boolean;
    get lc_aliases(): Record<string, string>;
    /**
     * @deprecated
     * Use {@link BaseMessage.content} instead.
     */
    get text(): string;
    /** The content of the message. */
    content: MessageContent;
    /** The name of the message sender in a multi-user chat. */
    name?: string;
    /** Additional keyword arguments */
    additional_kwargs: NonNullable<BaseMessageFields["additional_kwargs"]>;
    /** The type of the message. */
    abstract _getType(): MessageType;
    constructor(fields: string | BaseMessageFields, 
    /** @deprecated */
    kwargs?: Record<string, unknown>);
    toDict(): StoredMessage;
    toChunk(): BaseMessageChunk;
}
export type OpenAIToolCall = ToolCall & {
    index: number;
};
/**
 * Represents a chunk of a message, which can be concatenated with other
 * message chunks. It includes a method `_merge_kwargs_dict()` for merging
 * additional keyword arguments from another `BaseMessageChunk` into this
 * one. It also overrides the `__add__()` method to support concatenation
 * of `BaseMessageChunk` instances.
 */
export declare abstract class BaseMessageChunk extends BaseMessage {
    abstract concat(chunk: BaseMessageChunk): BaseMessageChunk;
    static _mergeAdditionalKwargs(left: NonNullable<BaseMessageFields["additional_kwargs"]>, right: NonNullable<BaseMessageFields["additional_kwargs"]>): NonNullable<BaseMessageFields["additional_kwargs"]>;
}
/**
 * Represents a human message in a conversation.
 */
export declare class HumanMessage extends BaseMessage {
    static lc_name(): string;
    _getType(): MessageType;
}
/**
 * Represents a chunk of a human message, which can be concatenated with
 * other human message chunks.
 */
export declare class HumanMessageChunk extends BaseMessageChunk {
    static lc_name(): string;
    _getType(): MessageType;
    concat(chunk: HumanMessageChunk): HumanMessageChunk;
}
/**
 * Represents an AI message in a conversation.
 */
export declare class AIMessage extends BaseMessage {
    static lc_name(): string;
    _getType(): MessageType;
}
/**
 * Represents a chunk of an AI message, which can be concatenated with
 * other AI message chunks.
 */
export declare class AIMessageChunk extends BaseMessageChunk {
    static lc_name(): string;
    _getType(): MessageType;
    concat(chunk: AIMessageChunk): AIMessageChunk;
}
/**
 * Represents a system message in a conversation.
 */
export declare class SystemMessage extends BaseMessage {
    static lc_name(): string;
    _getType(): MessageType;
}
/**
 * Represents a chunk of a system message, which can be concatenated with
 * other system message chunks.
 */
export declare class SystemMessageChunk extends BaseMessageChunk {
    static lc_name(): string;
    _getType(): MessageType;
    concat(chunk: SystemMessageChunk): SystemMessageChunk;
}
/**
 * Represents a function message in a conversation.
 */
export declare class FunctionMessage extends BaseMessage {
    static lc_name(): string;
    constructor(fields: FunctionMessageFieldsWithName);
    constructor(fields: string | BaseMessageFields, 
    /** @deprecated */
    name: string);
    _getType(): MessageType;
}
/**
 * Represents a chunk of a function message, which can be concatenated
 * with other function message chunks.
 */
export declare class FunctionMessageChunk extends BaseMessageChunk {
    static lc_name(): string;
    _getType(): MessageType;
    concat(chunk: FunctionMessageChunk): FunctionMessageChunk;
}
/**
 * Represents a tool message in a conversation.
 */
export declare class ToolMessage extends BaseMessage {
    static lc_name(): string;
    get lc_aliases(): Record<string, string>;
    tool_call_id: string;
    constructor(fields: ToolMessageFieldsWithToolCallId);
    constructor(fields: string | BaseMessageFields, tool_call_id: string, name?: string);
    _getType(): MessageType;
    static isInstance(message: BaseMessage): message is ToolMessage;
}
/**
 * Represents a chunk of a tool message, which can be concatenated
 * with other tool message chunks.
 */
export declare class ToolMessageChunk extends BaseMessageChunk {
    tool_call_id: string;
    constructor(fields: ToolMessageFieldsWithToolCallId);
    static lc_name(): string;
    _getType(): MessageType;
    concat(chunk: ToolMessageChunk): ToolMessageChunk;
}
/**
 * Represents a chat message in a conversation.
 */
export declare class ChatMessage extends BaseMessage implements ChatMessageFieldsWithRole {
    static lc_name(): string;
    role: string;
    static _chatMessageClass(): typeof ChatMessage;
    constructor(content: string, role: string);
    constructor(fields: ChatMessageFieldsWithRole);
    _getType(): MessageType;
    static isInstance(message: BaseMessage): message is ChatMessage;
}
export type BaseMessageLike = BaseMessage | [StringWithAutocomplete<MessageType | "user" | "assistant">, MessageContent] | string;
export declare function isBaseMessage(messageLike?: unknown): messageLike is BaseMessage;
export declare function isBaseMessageChunk(messageLike?: unknown): messageLike is BaseMessageChunk;
export declare function coerceMessageLikeToMessage(messageLike: BaseMessageLike): BaseMessage;
/**
 * Represents a chunk of a chat message, which can be concatenated with
 * other chat message chunks.
 */
export declare class ChatMessageChunk extends BaseMessageChunk {
    static lc_name(): string;
    role: string;
    constructor(content: string, role: string);
    constructor(fields: ChatMessageFieldsWithRole);
    _getType(): MessageType;
    concat(chunk: ChatMessageChunk): ChatMessageChunk;
}
/**
 * This function is used by memory classes to get a string representation
 * of the chat message history, based on the message content and role.
 */
export declare function getBufferString(messages: BaseMessage[], humanPrefix?: string, aiPrefix?: string): string;
export declare function mapStoredMessageToChatMessage(message: StoredMessage): ChatMessage | HumanMessage | AIMessage | SystemMessage | FunctionMessage | ToolMessage;
/**
 * Transforms an array of `StoredMessage` instances into an array of
 * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`
 * function to ensure all messages are in the `StoredMessage` format, then
 * creates new instances of the appropriate `BaseMessage` subclass based
 * on the type of each message. This function is used to prepare stored
 * messages for use in a chat context.
 */
export declare function mapStoredMessagesToChatMessages(messages: StoredMessage[]): BaseMessage[];
/**
 * Transforms an array of `BaseMessage` instances into an array of
 * `StoredMessage` instances. It does this by calling the `toDict` method
 * on each `BaseMessage`, which returns a `StoredMessage`. This function
 * is used to prepare chat messages for storage.
 */
export declare function mapChatMessagesToStoredMessages(messages: BaseMessage[]): StoredMessage[];
export {};
